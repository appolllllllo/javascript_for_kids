/* В нашем варианте «Виселицы» JavaScript будет выбирать слово,а игрок-человек — отгадывать буквы. И рисовать человечка наша программа не будет, поскольку мы пока не знаем, как это делается (рисованием на JavaScript мы займемся в главе 13). */

// Взаимодействие с игроком

/* Для этой игры нам нужно, чтобы игрок (человек) мог каким-то образом вводить в программу свои ответы. Один из способов это сделать — открывать диалоговое окно (в JavaScript оно называется prompt), в котором игрок может что-нибудь напечатать. */

// Создаем диалоговое окно

/* let name = prompt("Как вас зовут?");
console.log("Привет, " + name);

Здесь мы создали новую переменную name и присвоили ей значение, которое вернул вызов prompt("Как вас зовут?"). При вызове prompt открывается маленькое диалоговое окно.

Вызов prompt("Как вас зовут?") создает окно с запросом «Как вас зовут?» и строкой для ввода текста. В нижней части этого диалога есть две кнопки — «ОК» и «Отмена».

Если вы введете какой-нибудь текст и нажмете «ОК», этот текст станет значением, которое вернет в программу prompt. Например, если я введу свое имя и нажму «ОК», JavaScript напечатает в консоли:

Привет, Ник

Поскольку я ввел Ник и нажал на «ОК», строка "Ник" попала в переменную name, а вызов console.log напечатал: "Привет, " + "Ник", то есть "Привет, Ник".

Когда вы во второй раз создадите какое-либо диалоговое окно Chrome, в окне появится кнопка-флажок с подписью «Предотвратить создание дополнительных диалоговых окон на этой странице». Таким образом Chrome защищает пользователей от веб-страниц, открывающих множество назойливых рекламных окошек. Выполняя примеры из этой главы, просто отключите этот флажок. */

// А ЧТО ЕСЛИ ВЫ НАЖМЕТЕ «ОТМЕНА»?

/* Если вы нажмете кнопку «Отмена», prompt вернет значение null. Как нам известно из второй главы, null используется для обозначения чего-либо, что намеренно оставлено пустым.

После нажатия «Отмена» в консоли должно появиться:

Привет, null

В данном случае console.log печатает null как строку. Вообще-то null строкой не является, но, поскольку в консоль можно выводить только строки и вы попросили JavaScript напечатать "Привет, " + null, JavaScript преобразовал null в строку "null", чтобы напечатать это значение. Ситуация, когда JavaScript автоматически преобразует значение к другому типу, называется неявным приведением типа.

Неявное приведение типа — пример того, как JavaScript старается быть умным. Способа объединить строку и null не существует, и JavaScript делает лучшее, на что он способен. В данном случае он знает, что для успешного выполнения операции нужны две строки. Строковая версия значения null — это "null", и в результате мы видим в консоли "Привет, null". */

// Используем confirm, чтобы получить ответ «да» или «нет»

/* Функция confirm позволяет задать пользователю вопрос, на который он может ответить «да» или «нет» (что соответствует булеву значению). В следующем примере мы используем confirm, чтобы спросить у пользователя, нравятся ли ему кошки. Если получен утвердительный ответ, переменная likesCats принимает значение true и мы печатаем: «Ты классная кошка!» Если же кошки пользователю не нравятся, likesCats принимает значение false, и мы отвечаем: «Что ж, не проблема. Все равно ты молодец!»

let likesCats = confirm("Тебе нравятся кошки?");

if (likesCats) {
    console.log("Ты классная кошка!");
} else {
    console.log("Что ж, не проблема. Все равно ты молодец!");
}

Ответ на вопрос, заданный с помощью confirm, возвращается в программу как булево значение. Если в окне пользователь нажмет «ОК», confirm вернет true. Если же пользователь нажмет «Отмена», confirm вернет false. */

// Используем alert для выдачи информации

/* Если требуется просто показать что-то пользователю, можно воспользоваться диалогом alert, который отображает сообщение с кнопкой «ОК». Например, если вы считаете, что JavaScript — это здорово, вы можете использовать alert так:

alert("JavaScript это здорово!");

Диалог alert просто отображает сообщение до тех пор, пока пользователь не нажмет «ОК». */

// Чем alert лучше console.log?

/* Зачем нужен диалог alert, когда есть console.log?

Во-первых, если необходимо просто сообщить о чем-то игроку, alert позволяет сделать именно это — не требуя, чтобы игрок открыл консоль и прочитал сообщение.

Во-вторых, вызов alert (а также prompt и confirm) приостанавливает работу интерпретатора JavaScript до нажатия кнопки «ОК» (или «Отмена», в случае prompt) и — значит, у пользователя будет достаточно времени, чтобы прочитать сообщение. А при использовании console.log текст отображается в консоли, а интерпретатор тут же переходит к следующей строке программы. */

// Проектирование игры

/* Прежде чем перейти к созданию игры «Виселица», давайте подумаем о ее структуре. Нам нужно, чтобы программа умела выполнять следующие действия:

1. Случайным образом выбирать слово.

2. Запрашивать у игрока вариант ответа (букву).

3. Завершать игру по желанию игрока.

4. Проверять, является ли введенный ответ буквой.

5. Вести учет угаданных букв.

6. Показывать игроку, сколько букв он угадал и сколько еще предстоит угадать.

7. Завершать игру, если слово отгадано.

Все эти действия, кроме первого и последнего (выбор слова и завершение игры), нужно выполнять многократно, причем заранее неизвестно, сколько раз (это зависит от ответов игрока). И, как мы теперь знаем, если требуется повторять какие-то действия, значит, в программе нужен цикл.

Однако в нашем списке действий ничего не говорится о том, что и когда должно происходить. Чтобы выяснить этот вопрос и лучше представить себе структуру будущей программы, мы можем воспользоваться псевдокодом. */

// Используем псевдокод для проектирования игры

/* Псевдокод — удобный инструмент, который программисты часто используют при проектировании программ. Слово «псевдокод» означает «ненастоящий код». Хотя в псевдокоде есть циклы и условия, в целом программа описывается обычным человеческим языком. Чтобы разобраться, что это значит, давайте посмотрим на описание нашей игры в псевдокоде:

Выбрать случайное слово
Пока слово не угадано {
  Показать игроку текущее состояние игры
  Запросить у игрока вариант ответа
  Если игрок хочет выйти из игры {
    Выйти из игры
 }
 Иначе Если вариант ответа — не одиночная буква {
   Сообщить игроку, что он должен ввести букву
 }
 Иначе {
   Если такая буква есть в слове {
     Обновить состояние игры, подставив новую букву
   }
 }
}
Поздравить игрока с победой — слово угадано

Как видите, это не программный код, который может выполнить компьютер. Однако такая запись дает нам представление о структуре программы прежде, чем мы перейдем к написанию кода и выяснению мелких деталей, например, как именно выбирать случайное слово. */

// Отображение состояния игры

/* Одна из строк нашего псевдокода гласит: «Показать игроку текущее состояние игры». Для игры «Виселица» это означает подставить в слово угаданные игроком буквы, а также показать, какие буквы осталось угадать. Как мы будем это делать? В сущности, можно хранить состояние игры тем же способом, что и в обычной «Виселице»: в виде последовательности «пустых мест», которые мы будем заполнять по мере того, как игрок угадывает буквы.

Мы сделаем это с помощью массива «пустых мест» — по одному элементу для каждой буквы в слове. Назовем этот массив «итоговым массивом» и будем по ходу игры заполнять его угаданными буквами. А каждое из «пустых мест» представим в виде строки со знаком подчеркивания: "_".

Сначала наш итоговый массив будет просто набором «пустых мест», количество которых равно количеству букв в загаданном слове. Например, если загадано слово «рыба», массив будет выглядеть так:

["_", "_", "_", "_"]

Если игрок угадает букву «ы», мы заменим второй элемент на «ы»:

["_", "ы", "_", "_"]

А когда игрок угадает все буквы, массив примет вид:

["р", "ы", "б", "а"]

Также нам понадобится переменная для хранения количества букв, которые осталось
угадать. Для каждого вхождения верно угаданной буквы эта переменная будет уменьшаться на 1, и, когда она примет значение 0, мы поймем, что игрок победил. */

// Проектируем игровой цикл

/* Основная часть игры будет располагаться внутри цикла while (в нашем псевдокоде этот цикл начинается со строки «Пока слово не угадано»). В цикле мы будем отображать текущее состояние игры (то есть слово, поначалу представленное одними знаками подчеркивания), запрашивать у игрока вариант ответа (и проверять действительно ли тот ввел одиночную букву), а также обновлять итоговый массив, подставляя введенную букву, если она действительно есть в слове.

Практически все компьютерные игры организованы в виде того или иного цикла, нередко структурно похожего на цикл нашей «Виселицы». В целом игровой цикл выполняет следующие задачи:

1. Принимает ввод от игрока.

2. Обновляет состояние игры.

3. Показывает игроку текущее состояние игры.

Такого рода цикл применяется даже в играх, где непрерывно что-то меняется, — просто он выполняется очень быстро. В случае нашей «Виселицы» программа запрашивает у игрока вариант ответа, обновляет итоговый массив (если ответ верный) и отображает новое состояние итогового массива.

Если игрок угадает все буквы в слове, мы должны показать ему законченное слово, а также вывести сообщение, поздравляющее с победой. */

// Программируем игру

/* Теперь, когда у нас есть представление о структуре игры, можно переходить к написанию кода. Сначала мы рассмотрим его по частям. После этого вы увидите весь код целиком, чтобы с удобством ввести его и поиграть. */

// Выбираем случайное слово

/* Первым делом нам нужно выбрать случайное слово. Вот как это делается:

1. let words = [
    "программа",
    "макака",
    "прекрасный",
    "оладушек"
];

2. let word = words[Math.floor(Math.random() * words.length)];

Наша игра начинается со строки 1, где мы создаем массив со словами (программа, макака, прекрасный и оладушек), из которого затем будем выбирать слово для отгадывания (все слова должны быть записаны строчными буквами). Cохраним этот массив в переменной words. В строке 2 мы используем Math.random и Math.floor, чтобы выбрать из массива случайное слово — так же как в третьей главе выбирали слова для генератора дразнилок. */

// Создаем итоговый массив

/* Далее создадим пустой массив под названием answerArray (итоговый массив) и заполним его символами подчеркивания (_), количество которых соответствует количеству букв в загаданном слове.

let answerArray = [];

1. for (let i = 0; i < word.length; i++) {
    answerArray[i] = "_";
}

let remainingLetters = word.length;

В строке 1 в начале цикла for создается переменная цикла i, которая сначала равна 0, а затем возрастает до word.length (не включая, однако, само значение word.length). При каждом повторе цикла мы добавляем в массив новый элемент — answerArray[i]. Когда цикл завершится, длина answerArray будет такой же, как длина слова. Например, если было выбрано слово «макака» (в котором шесть букв), answerArray примет вид [" _ ", " _ ", " _ ", " _ ", " _ ", " _ "] (шесть знаков подчеркивания). 

Наконец, создадим переменную remainingLetters, приравняв ее к длине загаданного слова. Эта переменная понадобится, чтобы отслеживать количество букв, которые осталось угадать. Каждый раз, когда игрок угадает букву, мы будем декрементировать (то есть уменьшать) значение этой переменной: на 1 для каждого вхождения буквы в слово. */

// Программируем игровой цикл

/* Основа игрового цикла выглядит так:

while (remainingLetters > 0) {
 // Основной код
 // Показываем состояние игры
 // Запрашиваем вариант ответа
 // Обновляем answerArray и remainingLetters для каждого
 // вхождения угаданной буквы
}

Мы используем цикл while, который будет повторяться до тех пор, пока условие remainingLetters > 0 дает true. В теле цикла надо будет обновлять remainingLetters для каждого правильного ответа игрока; когда игрок угадает все буквы, remainingLetters примет значение 0, и цикл завершится.

Далее мы рассмотрим код, составляющий тело игрового цикла. */

// Отображение состояния игры

/* Первым делом в теле игрового цикла нужно показать игроку текущее
состояние игры:

alert(answerArray.join(" "));

Мы делаем это, объединяя элементы answerArray в строку с пробелом в качестве разделителя, а затем с помощью alert показываем эту строку. Например, пусть загадано слово «макака» и игрок угадал буквы буквы «м» и «а». Тогда итоговый массив примет вид: ["м", "а", " _ ", "а", " _ ", "а"] и answerArray.join("") вернет строку "м а _ а _ а". */

// Обработка введенного ответа

/* Теперь нужно запросить у игрока ответ и убедиться, что он ввел одиночную букву.

1. let guess = promt("Угадайте букву или нажмите Отмена для выхода из игры");

2. if (guess === null) {
    break;
3. } else if (guess.length !== 1) {
    alert("Пожалуйста, введите только одну букву.");
4. } else {
    // Обновляем состояние игры
}

В строке 1 prompt запрашивает у игрока ответ и сохраняет его в переменной guess. Далее возможен один из четырех вариантов развития событий.

Первый вариант — если игрок нажмет кнопку «Отмена», guess примет значение null. Этот вариант мы проверяем в строке 2 командой if (guess === null). Если это условие даст true, мы с помощью break
выйдем из цикла.

Ключевое слово break можно использовать для немедленного выхода из любого цикла, независимо от того, где именно внутри цикла это происходит, или от того, выполняется ли на этот момент условие while.

Второй и третий варианты — игрок не ввел ничего либо ввел несколько букв. Если он просто нажал «ОК», ничего не вводя, в guess окажется пустая строка (""), а guess.length вернет 0. Если же игрок ввел больше одной буквы, guess.length вернет число больше 1.

В строке 3 мы с помощью else if (guess.length !== 1) обрабатываем эти варианты, то есть проверяем, что guess содержит в точности одну букву. В противном случае мы отображаем диалог alert, гласящий: «Пожалуйста, введите только одну букву».

Четвертый вариант — игрок, как и положено, ввел одну букву. Тогда
мы должны обновить состояние игры — это происходит в строке 4, в секции else. Об этом пойдет речь ниже. */

// Обновление состояния игры

/* Если игрок ввел корректный ответ, мы должны обновить answerArray согласно этому ответу. Для этого добавим в тело else такой код:

1. for (let j = 0; j < word.length; j++) {
2.    if (word[j] === guess) {
        answerArray[j] = guess;
3.        remainingLetters--;
    }
}

В строке 1 мы задали цикл for с новой переменной j, которая будет менять значение от 0 до word.length, не включая само значение word.length. (Мы назвали переменную j, поскольку имя i уже использовано в предыдущем цикле for.) В этом цикле мы проверяем каждую букву переменной word. Например, пусть в word находится строка "оладушек". Тогда при первом повторе цикла, когда j равно 0, word[j] вернет "о". При следующем повторе word[j] вернет "л", затем "а", "д", "у", "ш", "е" и, наконец, "к".

В строке 2 мы с помощью if (word[j] === guess) проверяем, совпадает ли текущая буква (word[j]) с ответом игрока. Если это так, мы обновляем итоговый массив, добавляя туда букву командой answerArray[j] = guess. Для каждой буквы, совпадающей с ответом, мы обновляем соответствующую позицию итогового массива. Этот код работает, поскольку переменную цикла j можно использовать одновременно в качестве индекса в строке word и индекса в массиве
answerArray.

Например, представим, что мы только начали игру и дошли до цикла for в строке 1. Пусть загадано слово «программа», в guess находится буква "р", а answerArray имеет вид:

["_", "_", "_", "_", "_", "_", "_", "_", "_"]

При первом повторе for в строке 1 j равно 0, поэтому word[j] вернет "п". Наш ответ (guess) — это "р", поэтому мы пропускаем команду if в строке  (ведь условие "п" === "р" дает false). При следующем повторе j равно 1, и word[j] вернет "р". Это значение совпадает с guess, и срабатывает оператор if. Команда answerArray[j] = guess присваивает элементу с индексом 1 (второй элемент) массива answerArray значение guess, и теперь answerArray имеет вид:

["_", "р", "_", "_", "_", "_", "_", "_", "_"]

При следующих двух повторах цикла word[j] вернет "о", а затем "г", что не совпадает со значением guess. Однако когда j достигнет 4, word[j] снова вернет "р". И снова мы обновим answerArray, на этот раз присвоив значение guess элементу с индексом 4 (пятый элемент). Теперь answerArray выглядит так:

["_", "р", "_", "_", "р", "_", "_", "_", "_"]

Оставшиеся буквы не совпадают с "р", так что при дальнейших повторах ничего не произойдет. Так или иначе, после завершения цикла в answerArray будут внесены все совпадения guess с соответствующими позициями word.

Помимо обновления answerArray для каждого совпадения с guess требуется уменьшать remainingLetters на 1. Мы делаем это в строке 3 командой remainingLetters--;. Каждый раз, когда guess совпадает с буквой из word, remainingLetters уменьшается на 1, и, когда игрок угадает все буквы, remainingLetters примет значение 0.

// Конец игры

Как мы знаем, игровой цикл while выполняется при условии remainingLetters > 0, поэтому его тело будет повторяться до тех пор, пока еще остаются неотгаданные буквы. Когда же remainingLetters уменьшится до 0, цикл завершится. После цикла нам остается лишь закончить игру — это позволяет сделать такой код:

alert(answerArray.join(" "));
alert("Отлично! Было загадано слово " + word);

В первой строке мы последний раз отображаем итоговый массив. Во второй строке, опять же с помощью alert, мы поздравляем игрока с победой. */

// Код игры

/* Итак, мы разобрали по частям весь код игры, осталось лишь соединить все вместе. Ниже он приведен целиком, от начала до конца. Я добавил в него комментарии, поясняющие, что происходит в том или ином месте программы. Обязательно вручную введите код в компьютер — это поможет вам поскорее набить руку в JavaScript. */

// Создаем массив со словами
let words = [
    "программа",
    "макака",
    "прекрасный",
    "оладушек"
];

// Выбираем случайное слово
let word = words[Math.floor(Math.random() * words.length)];

// Создаем итоговый массив
let answerArray = [];
for (let i = 0; i < word.length; i++) {
    answerArray[i] = "_";
}

let remainingLetters = word.length;

// Итоговый цикл
while (remainingLetters > 0) {
    // Показываем состояние игры
    alert(answerArray.join(" "));

    // Запрашиваем вариант ответа
    let guess = prompt("Угадайте букву, или нажмите Отмена для выхода из игры.");
    if (guess === null) {
        // Выходим из игрового цикла
        break;
    } else if (guess.length !== 1) {
        alert("Пожалуйста, введите одиночную букву.");
    } else {
        // Обновляем состояние игры
        for (let j = 0; j < word.length; j++) {
            if (word[j] === guess) {
                answerArray[j] = guess;
                remainingLetters--;
            }
        }
    }

    //Конец игрового цикла
}

// Отображаем ответ и поздравляем игрока
alert(answerArray.join(" "));
alert("Отлично! Было загадано слово " + word);