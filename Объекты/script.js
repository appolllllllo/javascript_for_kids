// Создание объектов

/* let cat = {
    "legs": 3,
    "name": "Гармония",
    "color": "Черепаховый"
}; */

// Ключи без кавычек

/* let cat = {
    legs: 3,
    name: "Гармония",
    color: "Черепаховый"
}; */

// JavaScript знает, что ключи всегда строковые, поэтому можно обходиться без кавычек. В этом случае имена ключей должны соответствовать тем же правилам, что и имена переменных: например, в них не должно быть пробелов. Но если ключ указан в кавычках, пробелы в его имени допустимы:

/* let cat = {
    legs: 3,
    "full name": "Гармония Филомена Уси-Пусечка Морган",
    color: "Черепаховый"
}; */

// Помните, что, хотя ключ всегда является строковым (в кавычках он записан или без), значение, соответствующее этому ключу, может быть любого типа — даже переменной, в которой хранятся данные.

// Доступ к значениям внутри объектов

// Хранящиеся в объектах значения можно получить с помощью квадратных скобок — так же, как элементы массива. Единственное различие в том, что вместо индекса (число) используется ключ (строка).

/* let cat = {
    legs: 3,
    name: "Гармония",
    color: "Черепаховый"
}; 

console.log(cat["name"]); */

// Точно так же, как необязательны кавычки при записи литерала объекта, их можно опускать и при доступе к значениям по ключу. Однако в этом случае код будет немного другим:

/* let cat = {
    legs: 3,
    name: "Гармония",
    color: "Черепаховый"
}; 

console.log(cat.name); */

// Такую запись называют точечной нотацией. Вместо того чтобы писать имя ключа в кавычках внутри квадратных скобок, мы просто ставим точку, после которой пишем имя ключа, без кавычек. И, аналогично ключам без кавычек при записи литерала, такой прием сработает, только если ключ не содержит специальных символов — например, пробелов.

// Теперь предположим, что вы хотите узнать, какие вообще ключи есть у данного объекта. Для этого в JavaScript есть удобное средство — команда Object.keys():

/* let dog = { name: "Оладушек", age: 6, color: "белый", bark: "Гав тяф тяф!" };
let cat = { name: "Гармония", age: 8, color: "черепаховый" };

console.log(Object.keys(dog));
console.log(Object.keys(cat)); */

// Object.keys(anyObject) возвращает массив, содержащий все ключи объекта anyObject.

// Добавление элементов объекта

// Пустой объект похож на пустой массив, только вместо квадратных скобок при его создании используются фигурные:

// let object = {};

// Добавлять элементы объекта можно так же, как элементы массива, — но используя строки вместо чисел:

/* let cat = {};

cat["legs"] = 3;
cat["name"] = "Гармония";
cat["color"] = "Черепаховый";

console.log(cat); */

// Chrome перечисляет ключи в таком порядке — (legs, name, color), но другие браузеры могут выводить их в другой очередности. Дело в том, что JavaScript хранит ключи объектов, не упорядочивая их.

// В массивах элементы расположены строго один за другим: индекс 0 перед индексом 1, индекс 3 после индекса 2; однако в случае объектов неясно, как расположить элементы друг относительно друга. Должен ли ключ color стоять перед legs или после? «Правильного» ответа на этот вопрос нет, поэтому объекты хранят свои ключи без конкретной очередности, в результате чего разные браузеры показывают ключи в разном порядке. Так что никогда не полагайтесь в своих программах на тот или иной порядок ключей.

// Добавление ключей через точку

/* let cat = {};

cat.legs = 3;
cat.name = "Гармония";
cat.color = "Черепаховый";

console.log(cat); */

// Если обратиться к несуществующему свойству объекта, JavaScript вернет специальное значение undefined, сообщая таким образом: «здесь ничего нет». Например:

/* let dog = {
 name: "Оладушек",
 legs: 4,
 isAwesome: true
};

console.log(dog.isBrown); */

// Здесь мы определили три свойства объекта dog: name, legs и isAwesome. Свойства isBrown среди них нет, поэтому dog.isBrown возвращает undefined.

// Массивы объектов

// До этого момента мы рассматривали только массивы и объекты, в которых содержатся данные простых типов, такие как числа и строки. Однако ничто не мешает сделать элементом массива или объекта другой массив или объект. Например, так может выглядеть массив с объектами, описывающими динозавров:

/* let dinosaurs = [
    { name: "Тираннозавр рекс", period: "Верхнемеловой" },
    { name: "Стегозавр", period: "Верхнеюрский"},
    { name: "Платеозавр", period: "Триасовый" }
];

// Получить сведения о первом динозавре можно уже известным нам способом — указав индекс в квадратных скобках:


console.log(dinosaurs[0]);

// А если нужно только название первого динозавра, достаточно указать ключ объекта в еще одних квадратных скобках, следом за индексом:

console.log(dinosaurs[0] ["name"]);

console.log(dinosaurs[0].period); */

// Точечную нотацию можно использовать только с объектами, для массивов она не подходит.

// Массив друзей

// Давайте рассмотрим более сложный пример — массив объектов со сведениями о друзьях, где в каждый из объектов вложено по еще одному массиву. Сначала создадим объекты, а затем поместим их в массив.

/* let anna = { name: "Анна", age: 11, luckyNumbers: [2, 4, 8, 16] };
let dave = { name: "Дэйв", age: 5, luckyNumbers: [3, 9, 40] };
let kate = { name: "Кейт", age: 9, luckyNumbers: [1, 2, 3] };

// Мы создали три объекта, сохранив их в переменных anna, dave и kate. У каждого из этих объектов есть по три свойства: name, age и luckyNumbers. Каждому ключу name соответствует строковое значение, ключу age — числовое, а ключу luckyNumbers — массив, содержащий несколько чисел. Теперь создадим массив друзей:

let friends = [anna, dave, kate];

// Итак, в переменной friends находится массив с тремя элементами: anna, dave и kate (каждый из них является объектом). Мы можем получить любой из объектов по его индексу в массиве:

console.log(friends[1]);

// Здесь мы извлекли из массива второй объект, dave (по индексу 1). Вместо массива luckyNumbers Chrome напечатал Array[3], что означает «это массив с тремя элементами» (можно изучить содержимое этого массива с помощью Chrome, см. раздел «Исследование объектов в консоли» на с. 77.) Также мы можем получить значение, хранящееся в объекте, указав индекс объекта в квадратных скобках, поставив точку и написав соответствующий ключ:

console.log(friends[2].name);

// Этот код запрашивает элемент по индексу 2 (что соответствует переменной kate), а затем — свойство этого объекта, хранящееся по ключу "name" (это "Кейт"). Можно даже получить значение из массива, находящегося в объекте, который, в свою очередь, находится в массиве friends:

console.log(friends[0].luckyNumbers[1]);

// Исследование объектов в консоли

console.log(friends[1]);

//Не беспокойтесь о свойствах с названием __proto__, они относятся к прототипу объекта. Мы поговорим о прототипах позже, в главе 12. Обратите внимание, что помимо элементов массива интерпретатор показывает его свойство length. Также вы можете просмотреть массив friends целиком и раскрыть каждый его элемент */

// Что полезного можно сделать с объектами

// Учет долгов

// Предположим, вы решили открыть банк. Вы одолжили друзьям денег и теперь думаете, как вести учет того, кто и сколько вам должен. Можно использовать объект как способ связать строку с числом. Строкой в нашем случае будет имя друга, а числом — сумма, которую вам должны:

/* let owedMoney = {};

owedMoney["Джимми"] = 5;
owedMoney["Анна"] = 7;

console.log(owedMoney["Джимми"]);

owedMoney["Джимми"] += 3;

console.log(owedMoney["Джимми"]);

console.log(owedMoney); */

// Хранение информации о фильмах

// Предположим, у вас большая коллекция кино на DVD и Bluray. Правда было бы здорово хранить информацию об этих фильмах на компьютере, чтобы в случае чего быстро найти сведения о том или ином фильме?

// Для этого можно создать объект, каждый ключ в котором — это название фильма, а каждое значение — другой объект, в котором содержится информация об этом фильме. Да, хранящиеся в объекте значения тоже могут быть объектами!

/* let movies = {
    "В поисках Немо": {
        releaseDate: 2003,
        duration: 100,
        actors: ["Альберт Брукс", "Эллен Дедженерес", "Александр Гоулд"],
        format: "DVD"
    },
    "Звездные войны: Эпизод VI — Возвращение джедая": {
        releaseDate: 1983,
        duration: 134,
        actors: ["Марк Хэмилл", "Харрисон Форд", "Кэрри Фишер"],
        format: "DVD"
    },
    "Гарри Поттер и Кубок огня": {
        releaseDate: 2005,
        duration: 157,
        actors: ["Дэниел Рэдклифф", "Эмма Уотсон", "Руперт Гринт"]
    }
};

// Наверное, вы заметили, что названия фильмов (ключи внешнего объекта) я поставил в кавычки, но ключи внутренних объектов записал без кавычек. Дело в том, что в названиях нужны пробелы — иначе пришлось бы писать нечто вроде ЗвездныеВойныЭпизодVIВозвращениеДжедая,а это уж совсем нелепо. Для ключей вложенных объектов кавычки необязательны, поэтому я их и не ставил. Код выглядит аккуратнее, когда в нем нет излишних знаков пунктуации.

let findingNemo = movies["В поисках Немо"];

console.log(findingNemo.duration);

console.log(findingNemo.format);

let cars = {
    releaseDate: 2006,
    duration: 117,
    actors: ["Оуэн Уилсон", "Бонни Хант", "Пол Ньюман"],
    format: "Blu-ray"
};

movies["Тачки"] = cars;

console.log(Object.keys(movies)); */